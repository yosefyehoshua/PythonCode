############################################################################## FILE : client.py# WRITER : Yoav Galtzur, yoav.galtzur, 203372511# WRITER : Yosef Yehoshua, yosef12345, 302818513# EXERCISE : intro2cs ex12 2015-2016# DESCRIPTION : Containing two classes for the community board app:# Client - A class in charge of communicating with the server and interpreting# the server's messages# AppManager - Class that is in charge of managing the operation of the# drawing board, initiating the communication with the server,# the GUI and binding events.########################################################################################################################################################### IMPORTS#############################################################################import socketimport sysfrom board import Shapefrom board import DrawingBoardimport reimport select############################################################################## CONSTANTS#############################################################################HOST = 'localhost'PORT = 5000BUFF_SIZE = 1024MSG_DELIMITER = b'\n'DECODING_METHOD = 'ascii'LEAVE_MSG = 'leave'SHAPE_MSG = 'shape'ADD_USER_MSG = 'join'ADD_USERS_MSG = 'users'ERROR_MSG = 'error'MSG_SEPARATOR = ';'MAX_CHAR = 20IN_MSG_SEPARATOR = ","END_MSG = '\n'DEF_TIME_OUT = 0.33DEF_AFTER = 300INVALID_NAME_MSG = \    "username must be less than 20 chars and contains only number" \    " and/or letter, please try again"INVALID_GRP_NAME_MSG = \    "group name must be less than 20 chars and contains only number" \    " and/or letter, please try again"############################################################################## Client CLASS#############################################################################class Client:    """    A class in charge of communicating with the server and interpreting    the server's messages    """    def __init__(self, host, port, name, group_name):        """        :param host: server address        :param port: port        :param name: user name        :param group_name: group name        """        self.__host = host        self.__port = int(port)        self.__socket = socket.socket()        self.__name = name        self.__group_name = group_name        self.__buffer = b''        self.__drawing_board = DrawingBoard(name, group_name)        self.__socket.connect((self.__host, self.__port))        self.msg_to_server(            ADD_USER_MSG + MSG_SEPARATOR + self.__name +            MSG_SEPARATOR + self.__group_name + END_MSG)    def connect_to_server(self):        """        connects to server        """        self.__socket.connect((self.__host, self.__port))    def msg_to_server(self, msg):        """        Encodes and sends massage to the server        """        encoded_msg = bytes(msg, DECODING_METHOD)        self.__socket.sendall(encoded_msg)    def receive_from_server(self):        """        receives a massage from server, decoding it, and checking for        the next one        """        data = b''        r, w, x = select.select([self.__socket], [], [], DEF_TIME_OUT)        for sock in r:            if sock == self.__socket:                data = r[0].recv(BUFF_SIZE)        data = self.__buffer + data        while MSG_DELIMITER in data:            self.msg_to_action(                data[:data.index(MSG_DELIMITER)].decode(DECODING_METHOD))            data = data[data.index(MSG_DELIMITER) + 1:]        self.__buffer = data        self.__drawing_board.get_root().after(DEF_AFTER,                                              self.receive_from_server)    def leave_group(self):        """        When the X button on the GUI is pressed:        disconnects from server, closing GUI        """        self.msg_to_server(LEAVE_MSG)        self.__socket.close()        self.get_board().get_root().destroy()    def get_name(self):        """        :return: the client's username        """        return self.__name    def get_board(self):        """        :return: the actual drawing board        """        return self.__drawing_board    def msg_to_action(self, data):        data_list = data.split(MSG_SEPARATOR)        if data_list[0] == ADD_USER_MSG:            self.__drawing_board.add_user(data_list[1])        elif data_list[0] == SHAPE_MSG:            if data_list[1] != self.__name:                # unpack the coordinates stored in data_list[3]                temp_coor_list = data_list[3].split(IN_MSG_SEPARATOR)                coor_list = []                index = 0                # Go over all separate coordinates                while index < len(temp_coor_list) - 1:                    # Make every pair of X,Y a tuple of ints                    coor = (                        int(temp_coor_list[index]),                        int(temp_coor_list[index + 1]))                    coor_list.append(coor)                    index += 2                new_shape = Shape(data_list[1], data_list[2], coor_list,                                  data_list[4])                self.__drawing_board.add_shape(new_shape)  # add shape to GUI        elif data_list[0] == LEAVE_MSG:            self.__drawing_board.remove_user(data_list[1])        elif data_list[0] == ADD_USERS_MSG:            data_list.remove(data_list[0])            if IN_MSG_SEPARATOR in data_list[0]:                users_list = data_list[0].split(IN_MSG_SEPARATOR)            else:                users_list = data_list            for user in users_list:                self.__drawing_board.add_user(user)        elif data_list[0] == ERROR_MSG:            self.__drawing_board.show_error_msg(data_list[1])############################################################################## DrawManager CLASS#############################################################################class AppManager:    """    Class that is in charge of managing the operation of the drawing board,    initiating the communication with the server, the GUI and binding events.    """    def __init__(self):        self.__host = sys.argv[1]        self.__port = sys.argv[2]        self.__name = sys.argv[3]        self.__group_name = sys.argv[4]        self.__invalid_chars_pattern = re.compile('\W|\w*\W')        self.get_valid_input()        self.__client = None    def get_valid_input(self):        """        Checks if the in input given by the user is valid, keeps on trying        intul success. conditions:        1. Port must be an int        2. each name (group and user name) must be under 20 chars and        containing only letters, numbers and underscore        updates the AppManager's attributes with the valid info.        """        valid = False        while not valid:            valid = True            # Check port validity            try:                int(self.__port)                # break            except ValueError:                print("port must be an int, please try again")                valid = False                self.__port = input()            # Check username validity            if len(self.__name) > MAX_CHAR or bool(                    self.__invalid_chars_pattern.match(self.__name)):                valid = False                print(INVALID_NAME_MSG)                self.__name = input()            # Check group name validity            if len(self.__group_name) > MAX_CHAR or bool(                    self.__invalid_chars_pattern.match(self.__group_name)):                valid = False                print(INVALID_GRP_NAME_MSG)                self.__group_name = input()        self.__port = int(self.__port)    def run_loop(self):        self.__client.get_board().get_root().mainloop()    def shape_to_msg(self, shape):        """        converts a shape given to a message in order to send it to the server        :param shape: a shape that was drawn by the GUI (by this specific        client).        :return: the relevant message in format (string)        """        coor_str = ''        for coord in shape.get_coors():            coor_str += str(coord[0]) + IN_MSG_SEPARATOR            coor_str += str(coord[1]) + IN_MSG_SEPARATOR        coor_str = coor_str[:-1]  # remove the last comma        msg = "shape" + MSG_SEPARATOR + \              shape.get_name() + MSG_SEPARATOR + coor_str + MSG_SEPARATOR \              + shape.get_color() + END_MSG        return str(msg)    def canvas_pressed_runner(self, coors):        """        every time the drawing board gets pressed this function calls        the relevant function in the GUI        if it gets the newly drawn image, updates the server        :param coors: the coordinates just pressed by the user on the GUI's        board        """        new_shape = self.__client.get_board().canvas_pressed(coors)        if new_shape:            msg = self.shape_to_msg(new_shape)            self.__client.msg_to_server(msg)    def run(self):        """        Initiates the connection with the server, via the newly created client        binds events to widgets in thr GUI.        """        self.__client = Client(self.__host, self.__port, self.__name,                               self.__group_name)        self.__client.get_board().get_drawing_board().bind('<Button-1>',                                                self.canvas_pressed_runner)        self.__client.get_board().get_root().after(DEF_AFTER,                                            self.__client.receive_from_server)        self.__client.get_board().get_root().protocol("WN_DELETE_WINDOW",                                                    self.__client.leave_group)        self.run_loop()if __name__ == "__main__":    app = AppManager()    app.run()